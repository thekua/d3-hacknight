<html>
<head>
    <script type="text/javascript" src="lib/d3.v3.min.js"></script>
    <script type="text/javascript" src="lib/underscore-min.js"></script>
    <style>

        #chart {
            height: 506px;
        }

        text {
            font: 10px sans-serif;
        }

        .dot {
            stroke: #000;
        }

        .axis path, .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .label {
            fill: #777;
        }

        .year.label {
            font: 500 196px "Helvetica Neue";
            fill: #ddd;
        }

        .year.label.active {
            fill: #aaa;
        }

        .overlay {
            fill: none;
            pointer-events: all;
            cursor: ew-resize;
        }


    </style>
</head>
<body>
<div id="chart"></div>

<script type="text/javascript">
    
    // http://bost.ocks.org/mike/nations/

    var typesToColors = {
        "Employment" : "#4169e1",
        "Study" : "#87ceeb",
        "Family route" : "#8a2be2",
        "Dep. joining / acc" : "#b0e0e6",
        "Other" : "#cccccc"
    };

    var quarters = ["Q1 2005", "Q2 2005", "Q3 2005", "Q4 2005", "Q1 2006", "Q2 2006", "Q3 2006", "Q4 2006", "Q1 2007", "Q2 2007", "Q3 2007", "Q4 2007", "Q1 2008", "Q2 2008", "Q3 2008", "Q4 2008", "Q1 2009", "Q2 2009", "Q3 2009", "Q4 2009", "Q1 2010", "Q2 2010", "Q3 2010", "Q4 2010", "Q1 2011"];

    var duration = 10000;
    var graphWidth = 1200;

    d3.csv("control-immigration-q1-2011-main.csv", function(unparsedData) {
        var interestingData = unparsedData.slice(18);
        var convert = function(quarter, value, type, type2, person) {
            var value = value.replace(/,/, ''); // get rid of formatting
            var parsedNumber = parseInt(value);
            if (isNaN(parsedNumber)) {  // deal with funny characters
                parsedNumber = 1;
            }
            return {
                x: quarter,
                y: parsedNumber,
                radius: 10,
                color: typesToColors[type],
                type: type,
                type2: type2,
                person: person
            };
        };

        var resultsByQuarter = {};
        _.each(quarters, function(key, index) {
            var result = interestingData.map(function(row) {
                var type = row["Type"];
                var type2 = row["Type 2"];
                var person = row["Person"];
                var value = row[key];
                return convert(index + 1, value, type, type2, person);
            });
            resultsByQuarter[key] = result.splice(28, 30);
        });

        drawChart(resultsByQuarter);
    });

    var drawChart = function(data) {

        // console.log(data);

        // Chart dimensions.
        var margin = {top: 19.5, right: 19.5, bottom: 19.5, left: 39.5},
                width = graphWidth - margin.right,
                height = 500 - margin.top - margin.bottom;


        // Various scales. These domains make assumptions of data, naturally.
        var xScale = d3.scale.linear().domain([0.0, quarters.length]).range([0, width]),
                yScale = d3.scale.linear().domain([1, 120000]).range([height, 0]),
                radiusScale = d3.scale.sqrt().domain([0, 5e8]).range([0, 40]);

        // The x & y axes.
        var xAxis = d3.svg.axis().orient("bottom").scale(xScale).ticks(quarters.length),
                yAxis = d3.svg.axis().scale(yScale).orient("left");

        // Create the SVG container and set the origin.
        var svg = d3.select("#chart").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Add the x-axis.
        svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);

        // Add the y-axis.
        svg.append("g")
                .attr("class", "y axis")
                .call(yAxis);


        var dot = svg.append("g")
                .attr("class", "dots")
                .selectAll(".dot")
                .data(data[quarters[0]])
                .enter().append("circle")
                .attr("class", "dot")
                .style("fill", function(d) { return d.color; })
                .call(position);
        
        dot.append("title")
            .text(function(d) { return d.type; });

        svg.transition()
          .duration(duration)
          .ease("linear")
          .tween("quarter", tweenQuarter);

        // Tweens the entire chart by first tweening the year, and then the data.
        // For the interpolated data, the dots and label are redrawn.
        function tweenQuarter() {
            var quarter = d3.interpolateNumber(1, quarters.length);
            return function(t) { displayQuarter(quarter(t), t); };
        }

        function endAnimation() {
            console.log("ending");
            svg.transition().duration(0);
        }

        // Updates the display to show the specified year.
        function displayQuarter(quarterIndex, t) {

            dot.data(interpolateData(quarterIndex, t)).call(position);
            //label.text(Math.round(quarterIndex));
        }

        // Called for each point on the x-axis
        function interpolateData(quarterIndex, t) {
            if (quarterIndex >= quarters.length - 1) {
                endAnimation();
            } else {
                
                var oneTickDuration = duration / quarters.length;

                var quarterData = data[quarters[Math.round(quarterIndex)]];
                
                var interpolatedX = d3.interpolateNumber(quarterIndex, quarterIndex + 1)(t);

                return quarterData.map(function(d, index) {
                    var y = d.y;
                    if(quarterData[index + 1]) {
                        
                        var interpolateY = d3.interpolateNumber(d.y, quarterData[index + 1].y);
                        y = interpolateY(t);
                        
                    }
                    return {
                        x: interpolatedX,
                        y: y,
                        radius: 10
                    };
                });
            }
        }

        function position(dot) {
            dot .attr("cx", function(d) { /*console.log(d.x, xScale(d.x));*/ return xScale(d.x); })
                    .attr("cy", function(d) { return yScale(d.y); })
                    .attr("r", function(d) { return d.radius; });
        }



    };



</script>

</body>
</html>